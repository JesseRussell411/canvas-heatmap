{"version":3,"file":"gradientGenerator.js","sourceRoot":"","sources":["../../src/gradientGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["import { GradientStops, Gradient } from \"./types/gradient\";\r\nimport Color from \"color\";\r\n\r\nexport const defaultGradientStops: GradientStops = {\r\n    1: \"red\",\r\n    0.5: \"yellow\",\r\n    0: \"blue\",\r\n} as const;\r\n\r\nexport const defaultGradient = generateGradient(defaultGradientStops);\r\n\r\n\r\n/**\r\n * Generates a {@link Gradient} from the provided color stops.\r\n * @param colorStops An object where the key is a color stop's offset and the value is its color.\r\n * @returns A {@link Gradient}.\r\n */\r\nexport function generateGradient(\r\n    colorStops?: GradientStops\r\n): Uint8ClampedArray {\r\n    if (undefined === colorStops) return defaultGradient;\r\n\r\n    if (Array.isArray(colorStops)) {\r\n        // convert array of color stops to object\r\n        \r\n        // special case of 1 color stop\r\n        if (colorStops.length === 1){\r\n            return generateGradient({\r\n                0: colorStops[0]\r\n            })\r\n        }\r\n\r\n        const colorStopsObject = Object.fromEntries(\r\n            colorStops.map((color, i) => [i / (colorStops.length - 1), color])\r\n        );\r\n        return generateGradient(colorStopsObject);\r\n    }\r\n\r\n    /** The byte array that will eventually contain the gradient. */\r\n    const result = new Uint8ClampedArray(256 * 4);\r\n\r\n    /** A color stop that has been shaped to a consistent object. */\r\n    type PreppedColorStop = readonly [\r\n        offset: number,\r\n        color: Readonly<{\r\n            red: number;\r\n            green: number;\r\n            blue: number;\r\n            alpha: number;\r\n        }>\r\n    ];\r\n\r\n    const preppedColorStops: PreppedColorStop[] = Object.entries(colorStops)\r\n        // object keys are strings, parse them to numbers\r\n        .map(stop => [parseFloat(stop[0]), stop[1]] as const)\r\n        // remove NaN offsets\r\n        .filter(stop => !Number.isNaN(stop[0]))\r\n        // final shaping of the color stops\r\n        .map(stop => {\r\n            // parse the color string using the color package from npm\r\n            const color =\r\n                stop[1] instanceof Color ? stop[1] : new Color(stop[1]);\r\n\r\n            return [\r\n                stop[0],\r\n                // get the red,green,blue,alpha values from the color objects\r\n                {\r\n                    red: color.red(),\r\n                    green: color.green(),\r\n                    blue: color.blue(),\r\n                    alpha: color.alpha() * 255,\r\n                },\r\n            ] as const;\r\n        });\r\n\r\n    // if there where no color stops return a blank gradient\r\n    if (preppedColorStops.length === 0) return result;\r\n\r\n    // sort the color stops by their offset (ascending)\r\n    preppedColorStops.sort((a, b) => a[0] - b[0]);\r\n\r\n    // convert the color stop offsets from 0 - 1 to 0 - 255\r\n    // have to cast stop to non-readonly to do this.\r\n    preppedColorStops.forEach(\r\n        stop => ((stop as [...PreppedColorStop])[0] *= 255)\r\n    );\r\n\r\n    // if there's no stop for 0, add one and if there's no stop for 255, add that one too.\r\n    if (preppedColorStops[0]![0] > 0) {\r\n        preppedColorStops.unshift([\r\n            0,\r\n            { red: 0, green: 0, blue: 0, alpha: 0 },\r\n        ] as const);\r\n    }\r\n    if (preppedColorStops[preppedColorStops.length - 1]![0] < 255) {\r\n        preppedColorStops.push([\r\n            255,\r\n            { red: 0, green: 0, blue: 0, alpha: 0 },\r\n        ] as const);\r\n    }\r\n\r\n    // *at this point, there must be at least 2 color stops in the color stop array.\r\n\r\n    /** The index of the color stop preceding i. */\r\n    let colorStop1i = 0;\r\n    /** The index of the color stop following i. */\r\n    let colorStop2i = 1;\r\n\r\n    // calculate the color for each value from 0 to 255.\r\n    for (let i = 0; i < 256; i++) {\r\n        // check if i is past the following color stop and increment the color stops if it is.\r\n        // While-loop incase of color stops less than 1 apart (200, 200.2).\r\n        // *thanks to the format of this function, it is impossible for color stops to have duplicate\r\n        // offsets, unless the user disobeys typescript and uses strings for the keys to the colorStops\r\n        // argument. Then they could enter: {[\"1\"]: \"red\", [\"1.0\"]: \"green\"} but this probably wouldn't\r\n        // cause a crash.\r\n        while (i > preppedColorStops[colorStop2i]![0]) {\r\n            colorStop1i++;\r\n            colorStop2i++;\r\n        }\r\n        /** The preceding color stop. */\r\n        const colorStop1 = preppedColorStops[colorStop1i]!;\r\n        /** The following color stop. */\r\n        const colorStop2 = preppedColorStops[colorStop2i]!;\r\n\r\n        /** The distance from i to the preceding color stop. */\r\n        const colorStopDistance1 = Math.abs(i - colorStop1[0]);\r\n        /** the distance from i to the following color stop. */\r\n        const colorStopDistance2 = Math.abs(colorStop2[0] - i);\r\n\r\n        const totalDistance = colorStopDistance1 + colorStopDistance2;\r\n\r\n        // calculate each channel's value\r\n        const ri = i * 4;\r\n\r\n        // incase of duplicate offsets where they are on top of each other and the distance between them is 0\r\n        // and i is also on top of them, at the same value as the two offset\r\n        // I hope the CPU's branch prediction figures out that is is almost always false\r\n        if (totalDistance === 0) {\r\n            let chnl: \"red\" | \"green\" | \"blue\" | \"alpha\";\r\n\r\n            chnl = \"red\";\r\n            result[ri + 0] = (colorStop1[1][chnl] + colorStop2[1][chnl]) / 2;\r\n\r\n            chnl = \"green\";\r\n            result[ri + 0] = (colorStop1[1][chnl] + colorStop2[1][chnl]) / 2;\r\n\r\n            chnl = \"blue\";\r\n            result[ri + 0] = (colorStop1[1][chnl] + colorStop2[1][chnl]) / 2;\r\n\r\n            chnl = \"alpha\";\r\n            result[ri + 0] = (colorStop1[1][chnl] + colorStop2[1][chnl]) / 2;\r\n        } else {\r\n            result[ri + 0] = calcChannel(\r\n                \"red\",\r\n                colorStop1,\r\n                colorStop2,\r\n                colorStopDistance1,\r\n                colorStopDistance2,\r\n                totalDistance\r\n            );\r\n            result[ri + 1] = calcChannel(\r\n                \"green\",\r\n                colorStop1,\r\n                colorStop2,\r\n                colorStopDistance1,\r\n                colorStopDistance2,\r\n                totalDistance\r\n            );\r\n            result[ri + 2] = calcChannel(\r\n                \"blue\",\r\n                colorStop1,\r\n                colorStop2,\r\n                colorStopDistance1,\r\n                colorStopDistance2,\r\n                totalDistance\r\n            );\r\n            result[ri + 3] = calcChannel(\r\n                \"alpha\",\r\n                colorStop1,\r\n                colorStop2,\r\n                colorStopDistance1,\r\n                colorStopDistance2,\r\n                totalDistance\r\n            );\r\n        }\r\n    }\r\n\r\n    // I hope this function gets inlined\r\n    /** Calculate the value for a channel. */\r\n    function calcChannel(\r\n        channel: \"red\" | \"green\" | \"blue\" | \"alpha\",\r\n        colorStop1: PreppedColorStop,\r\n        colorStop2: PreppedColorStop,\r\n        colorStopDistance1: number,\r\n        colorStopDistance2: number,\r\n        totalDistance: number\r\n    ) {\r\n        /** The influence from the preceding stop. */\r\n        const color1 = colorStop1[1][channel] * colorStopDistance2;\r\n        /** The influence from the following stop. */\r\n        const color2 = colorStop2[1][channel] * colorStopDistance1;\r\n\r\n        // the reason why there's a check for totalDistance === 0 above\r\n        /** The average of the two influences. */\r\n        const totalColor = (color1 + color2) / totalDistance;\r\n\r\n        // clean up the result to make sure it is an integer from 0 to 255\r\n        return Math.max(0, Math.min(255, Math.round(totalColor)));\r\n    }\r\n\r\n    return result;\r\n}\r\n"]}